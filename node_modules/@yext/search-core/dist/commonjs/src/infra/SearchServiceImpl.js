"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchServiceImpl = void 0;
const createVerticalSearchResponse_1 = require("../transformers/searchservice/createVerticalSearchResponse");
const provideEndpoints_1 = require("../provideEndpoints");
const QuerySource_1 = require("../models/searchservice/request/QuerySource");
const createUniversalSearchResponse_1 = require("../transformers/searchservice/createUniversalSearchResponse");
const serializeStaticFilters_1 = require("../serializers/serializeStaticFilters");
const serializeFacets_1 = require("../serializers/serializeFacets");
const getClientSdk_1 = require("../utils/getClientSdk");
/**
 * The implementation of SearchService which hits LiveAPI.
 *
 * @internal
 */
class SearchServiceImpl {
    constructor(config, httpService, apiResponseValidator) {
        this.config = config;
        this.httpService = httpService;
        this.apiResponseValidator = apiResponseValidator;
        this.universalSearchEndpoint = config.endpoints.universalSearch;
        this.verticalSearchEndpoint = config.endpoints.verticalSearch;
    }
    universalSearch(request) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = Object.assign(Object.assign(Object.assign({ input: request.query, experienceKey: this.config.experienceKey }, ('apiKey' in this.config && { api_key: this.config.apiKey })), { v: provideEndpoints_1.defaultApiVersion, version: this.config.experienceVersion, limit: JSON.stringify(request.limit), location: this.stringifyLatLong(request.location), locale: this.config.locale, skipSpellCheck: request.skipSpellCheck, session_id: request.sessionId, sessionTrackingEnabled: request.sessionTrackingEnabled, queryTrigger: request.queryTrigger, context: JSON.stringify(request.context), referrerPageUrl: request.referrerPageUrl, source: request.querySource || QuerySource_1.QuerySource.Standard, visitorId: (_a = this.config.visitor) === null || _a === void 0 ? void 0 : _a.id, visitorIdMethod: (_b = this.config.visitor) === null || _b === void 0 ? void 0 : _b.idMethod, restrictVerticals: (_c = request.restrictVerticals) === null || _c === void 0 ? void 0 : _c.join(',') }), (_d = this.config) === null || _d === void 0 ? void 0 : _d.additionalQueryParams);
            const response = 'token' in this.config
                ? yield this.httpService.get(this.universalSearchEndpoint, queryParams, (0, getClientSdk_1.getClientSdk)(request.additionalHttpHeaders), this.config.token)
                : yield this.httpService.get(this.universalSearchEndpoint, queryParams, (0, getClientSdk_1.getClientSdk)(request.additionalHttpHeaders));
            const validationResult = this.apiResponseValidator.validate(response);
            if (validationResult instanceof Error) {
                return Promise.reject(validationResult);
            }
            return (0, createUniversalSearchResponse_1.createUniversalSearchResponse)(response);
        });
    }
    verticalSearch(request) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = Object.assign(Object.assign(Object.assign({ experienceKey: this.config.experienceKey }, ('apiKey' in this.config && { api_key: this.config.apiKey })), { v: provideEndpoints_1.defaultApiVersion, version: this.config.experienceVersion, locale: this.config.locale, input: request.query, location: this.stringifyLatLong(request.location), verticalKey: request.verticalKey, filters: request.staticFilter && (0, serializeStaticFilters_1.serializeStaticFilters)(request.staticFilter), limit: request.limit, offset: request.offset, retrieveFacets: request.retrieveFacets, facetFilters: request.facets && (0, serializeFacets_1.serializeFacets)(request.facets), skipSpellCheck: request.skipSpellCheck, queryTrigger: request.queryTrigger, session_id: request.sessionId, sessionTrackingEnabled: request.sessionTrackingEnabled, sortBys: JSON.stringify(request.sortBys || []), context: JSON.stringify(request.context), referrerPageUrl: request.referrerPageUrl, source: request.querySource || QuerySource_1.QuerySource.Standard, locationRadius: (_a = request.locationRadius) === null || _a === void 0 ? void 0 : _a.toString(), queryId: request.queryId, visitorId: (_b = this.config.visitor) === null || _b === void 0 ? void 0 : _b.id, visitorIdMethod: (_c = this.config.visitor) === null || _c === void 0 ? void 0 : _c.idMethod }), (_d = this.config) === null || _d === void 0 ? void 0 : _d.additionalQueryParams);
            const response = 'token' in this.config
                ? yield this.httpService.get(this.verticalSearchEndpoint, queryParams, (0, getClientSdk_1.getClientSdk)(request.additionalHttpHeaders), this.config.token)
                : yield this.httpService.get(this.verticalSearchEndpoint, queryParams, (0, getClientSdk_1.getClientSdk)(request.additionalHttpHeaders));
            const validationResult = this.apiResponseValidator.validate(response);
            if (validationResult instanceof Error) {
                return Promise.reject(validationResult);
            }
            return (0, createVerticalSearchResponse_1.createVerticalSearchResponse)(response);
        });
    }
    /**
     * Converts a {@link LatLong} into the format the Search API expects.
     */
    stringifyLatLong(latLong) {
        if (!latLong) {
            return undefined;
        }
        return `${latLong.latitude},${latLong.longitude}`;
    }
}
exports.SearchServiceImpl = SearchServiceImpl;
//# sourceMappingURL=SearchServiceImpl.js.map